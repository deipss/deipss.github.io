---
layout: default
title: 分布式事务
parent: Database
nav_order: 6
---

# CAP与BASE理论

## CAP

C:consistency,一致性
A:avliability，可用性
P:Partition tolerance，分区容错性
CAP理论不会同时满足，一般只能满足三种中其中两种。

## BASE

BA: basic available,基本可用
S:Soft state，软状态
E:Eventually consistent，最终一致性
在CAP的一致性与可用性上作权衡，满足在基本可用的情况下，允许部分节点暂时处于软状态，但要确保最终的一致性。

# 2pc

- 阶段一：事务协调器（XA）将所有参与到此次业务的数据库预提交
- 阶段二：无异常情况，全部提交；出现不一致或超时，全部回滚
  优点是保证数据的强一致性，适用于对数据强一致性要求高的领域如金融等。

## 缺点：

- 同步阻塞，参与事务占用的资源，会同步阻塞其他试图获取资源的事务
- XA的单点故障会引起整个系统不可用

# tcc

引入补偿事务：针对每个操作都注册了对应的确认和补偿，来保证数据一致性
try：先尝试预留所有此次业务需要的资源
confirm：确认所有资源可用，一般只try成功，confirm一定成功
cacel：业务执行错误，调用补偿机制，再释放资源

- 由业务发起方负责整个业务活动，XA也引入集群，避免单点故障引起系统不可用
- 引入超时，操作超时后会进行补偿，不用长期占用资源
  本地消息表

事务A修改后，以消息的形式发送给其他参与者

1. 当系统 A 被其他系统调用发生数据库表更操作，首先会更新数据库的业务表，其次会往相同数据库的消息表中插入一条数据，两个操作发生在同一个事务中
2. 系统 A 的脚本定期轮询本地消息往 mq 中写入一条消息，如果消息发送失败会进行重试
3. 系统 B 消费 mq 中的消息，并处理业务逻辑。如果本地事务处理失败，会在继续消费 mq 中的消息进行重试，如果业务上的失败，可以通知系统
   A 进行回滚操作
   本地消息表实现的条件：
1. 消费者与生成者的接口都要支持幂等
2. 生产者需要额外的创建消息表
3. 需要提供补偿逻辑，如果消费者业务失败，需要生产者支持回滚操作
   容错机制：
1. 步骤 1 失败时，事务直接回滚
2. 步骤 2、3 写 mq 与消费 mq 失败会进行重试
3. 步骤 3 业务失败系统 B 向系统 A 发起事务回滚操作
   此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。
   saga事务

# 参考

- https://xiaomi-info.github.io/2020/01/02/distributed-transaction/
- https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html
- https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673  【限流】
